% C Almost Generic Library Manual
%
% January 2014

# Introduction

The C Almost Generic Library (CAGL) provides *almost* generic containers and algorithms to manipulate them.

These containers are implemented: arrays, doubly-linked lists, singly linked lists, balanced binary trees (as red-black trees) and hash tables. The library manages the memory of its containers. It can also manage the memory of the elements of the containers.

Here is an example of how to use it to populate an array with random integers and then sum the array.

```C
/* Simple array of integers example.

   This program populates an array with random integers and sums them.

   Possible output:
   Sum is: 97
*/

#include <stdio.h>
#include <stdlib.h>
#include "cagl/array.h" /* CAGL array code. */

/* Declare and define an array of integers. */
CAG_DEC_DEF_ARRAY(int_arr, int);

int main(void)
{
	int_arr iarr; /* an array of integers. */
	it_int_arr it; /* an iterator over the array. */
	int total = 0;
	size_t i;

	new_int_arr(&iarr); /* Initiate container */

    /* populate the array with random integers. */
	for (i = 0; i < 10; ++i)
		append_int_arr(&iarr, rand() % 20);

	/* iterate over the array, summing its elements. */
    for (it = beg_int_arr(&iarr); it != end_int_arr(&iarr);
                                  it = next_int_arr(it))
    	total += it->value;
    printf("Sum is: %d\n", total);

   	free_int_arr(&iarr); /* Return array to heap. */
   	return 0;
}
```

# Installation

The CAGL source code is available on github at <https://github.com/nathangeffen/cagl>.

Installation instructions are contained in the README.md file. If you're familiar with the standard *autotools* installation (e.g. *./configure; make; sudo make install*), installation is straightforward.

# Purpose

Despite its age, C remains one of the most popular programming languages. It is fast and simple. Well-written C code is easy for most programmers to understand. It is widely used in embedded devices and vies with Java for top spot on the Tiobe Programming Index.

However, C comes with no standard libraries to handle the drudgery of the most needed data structures, or containers, such as arrays, trees, hash tables and lists. C++ provides the STL, but requires programmers to use an extremely complex language.

There are some excellent C generic libraries for managing containers such as [glib](https://developer.gnome.org/glib/) and [SGLIB](http://sglib.sourceforge.net/).

CAGL is inspired by *glib* and *SGLIB* but differs from both of them.

In contrast to glib which uses void pointers for generic types and requires primitive types to be passed by address, CAGL uses macro calls to define containers and generate functions that operate upon them.

SGLIB also uses macros except that CAGL, in contrast to SGLIB's expressed philosophy, manages memory for the container elements too. Also SGLIB provides macros to users. While a CAGL container is declared and defined using a macro call, subsequent operations on the container are typically done using functions generated by the macro that defined the container. (See the example above.)

Also, CAGL implements iterators, although these are not as flexible as the ones in the C++ STL.

CAGL is influenced by the C++ STL, but because C does not provide C++ syntactic features that make the STL possible (such as function overloading, constructors,  destructors, templates, exceptions etc), the CAGL has to differ significantly from the STL. Nevertheless, for programmers who have to use C or prefer C's simplicity over C++, the CAGL is potentially a convenient, time-saving, simple-to-use, even elegant library.

# Basic use

The CAGL is implemented almost entirely using C macros. These macros generate a set of functions for a container. Many of these functions are generic but have to be named uniquely for each container type because C doesn't support function overloading.

For example, the macro to declare and define a vanilla array of integers is     *CAG_DEC_DEF_ARRAY*. So this code declares *int_arr* which is a type name for an array of *int*.

```C
CAG_DEC_DEF_ARRAY(int_arr, int);
```

It also creates a set of functions that operate on variables of type *int_arr*. These functions all have *_int_arr* as a suffix. Some of these functions are:

new_int_arr(int_arr *array)
  ~ Initialise the array. Every CAGL container variable must be initialised with a call to a *new* function. Users of the C++ STL can think of this as a constructor.

new_with_capacity_int_arr(int_arr * array, const size_t reserve)
  ~ Also initialises the array, but specifies it initial capacity with *reserve*, overriding the default CAGL capacity specified by CAG_QUANTUM_ARRAY.

free_int_arr(int_arr *array)
  ~ Return an array to the heap. A *free* function should be called for every CAGL container variable once it is no longer used. Users of the C++ STL can think of this as a destructor.

reverse_int_arr(it_int_arr first, it_int_arr last)
  ~ Reverses all the elements between two iterators over an array variable. Every container type has an associated iterator type called *it*[container prefix]. In this example it is *it_int_arr*. Iterators are pointers to elements in the container. Every CAGL iterator variable has a member called value which is the value of the element. For C++ STL users, this is similar to **it*.

reverse_all_int_arr(int_arr *array)
  ~ Reverses all the elements between two iterators over an array variable.

distance_int_arr(it_int_arr first, it_int_arr last)
  ~ Returns the distance (number of elements) between two iterators over an array variable.

distance_all_int_arr(int_arr *array)
  ~ Returns the distance (number of elements) of an array variable.

You might have noticed that a function *x* that operates on all the elements of a container (which is the common case), as opposed to a sub-range within the container, is called *x_all_[container name]*.

Now to declare a variable which is an array of integers, you do this:

```C
int_arr iarr;
```

## Compiling CAGL programs

The library is called *almost* generic for several reasons, the main one being that the generic functions that are generated for different container types must have different names because C doesn't support function overloading. The library is also *almost* type safe, but not quite. C allows a function with pointer parameters to be called with pointers of a different type. This is usually a programming mistake. However mature C compilers will give warnings when this happens. An important principle of CAGL is that when you use it you should get no compiler warnings (at least as far as your use of CAGL goes).

When compiling a program that uses CAGL with *gcc* or *clang* using *-Wall -pedantic* any compiler warnings that arise in connection with CAGL should be considered errors. Conversely, any C compiler compliant with [ISO C 1990](http://en.wikipedia.org/wiki/ANSI_C#C89_and_C90) or later should compile well-written CAGL programs without warnings. For example, in development, you can compile the examples in this user guide using this (on GNU/Linux systems):

    cc -g -Wall -pedantic nameofprog.c -o nameofprog

Sometimes you need to link in code in cag_common.c. In which case this should work:

    cc -g -Wall -pedantic nameofprog.c cag_common.c  -o nameofprog

You can also compile cag_common.c into a shared library or to an object file like this:

	cc -g -Wall -pedantic -c cag_common.c

And then link it with your code like this:

	cc -g -Wall -pedantic nameofprog.c cag_common.o  -o nameofprog

Because CAGL generates many functions, only some of which your program might use, you might want to reduce the size of your executable in production. You can do this using *gcc* using the *-flto* option. For example:

	gcc -Wall -pedantic -O3 -flto nameofprog.c cag_common.o  -o nameofprog

Compiling with the *-flto* option can be slow, so you will likely only use it when compiling release builds.

## CAGL's main macros and functions

Every CAGL macro and function is prefixed *CAG_* (for macros) or *cag_* (for functions). Please consider this the namespace for CAGL and do not prefix your own code with *CAG_*.

The CAGL container include files are:

cagl/array.h
  ~ For declaring and defining automatically sized arrays similar to a C++ STL *vector*.

cagl/dlist.h
  ~ For declaring and defining doubly-linked lists similar to a C++ STL *list*.

cagl/slist.h
  ~ For declaring and defining singly-linked lists similar to a C++11 STL *forward_list*.

cagl/tree.h
  ~ For declaring and defining balanced binary trees (implemented as red-black trees) similar to a C++ STL *map*.

cagl/hash.h
  ~ For declaring and defining hash tables similar to a C++11 *unordered_map*.

The simplest way to declare and define a container whose elements are a particular type is to do this:

```
CAG_DEC_DEF_[ARRAY/DLIST/SLIST/HASH/TREE](name of container type, element type, ... other parameters ...);
```

This declares a doubly-linked list of doubles type and forward and reverse iterators for it. It also defines its supporting functions:

```C
CAG_DEC_DEF_DLIST(dbl_list, double);
```

The first parameter is the name of the container type. You can give this any legal C type name. The second parameter is an already existing C pointer, primitive type or struct (or *typedef*ed version thereof). The *DEC* stands for *declare* and the *DEF* stands for *define*. In C you should declare functions you use in each module that uses it, but you may only define the functions once. Therefore if you need a list of doubles two C files, say file1.c and file2.c, you would declare the type in, say, file1.h as follows:

```C
CAG_DEC_DLIST(dbl_list, double);
```

You would need to include file1.h in both file1.c and file2. Then in one C source code file only, say file1.c, you would define the functions like this:

```C
CAG_DEF_DLIST(dbl_list, double);
```

Arrays and lists may be ordered. Balanced binary trees have to be ordered. To declare an ordered CAGL container, you need to pass the definition macro a comparison function. For example, this declares a binary tree of integers:

```C
CAG_DEC_DEF_CMP_TREE(int_tree, int, CAG_CMP_DEFAULT);
```

*CAG_CMP_DEFAULT* is a CAGL macro that correctly compares the C primitive types. You could also do it this way:

```
CAG_DEC_CMP_TREE(int_tree, int);
CAG_DEF_CMP_TREE(int_tree, int, CAG_CMP_DEFAULT);
```

For C++ STL users, the above is similar to a std::map<int>.

The *CMP* part of the macro indicates that this is a container that requires a comparison function (or comparison macro such as CAG_CMP_DEFAULT), usually to maintain an ordering. However, not all all containers that require a comparison function are ordered.


Hash tables require a comparison function but are not ordered. Hash tables require a slightly more complicated macro. This declares and defines a hash table of C strings.

```C
CAG_DEC_DEF_CMP_HASH(str_hash, char *, strcmp, CAG_STRING_HASH, strlen);
```

The first parameter is the name of the container type. The second parameter is the C string type, *char **, which tells CAGL that the elements of this container are strings. The third parameter is the comparison function, which is the C standard library function *strcmp*. The fourth parameter is the default CAGL string hash function, *CAG_STRING_HASH*. The final parameter is a function for calculating the length of each element, the C standard library function *strcmp*.

Note: To compile a hash table that uses one of the default hash functions, you need to compile and link *cag_common.c*.

The following code snippet is an example of how to populate the hash table:

```C
static void populate_str_hash(str_hash *h)
{
	char *k0 = "k0";
	char *k1 = "k1";
	char *k2 = "k2";
	char *k3 = "k3";
	char *k4 = "k4";

	insert_str_hash(h, k0);
	insert_str_hash(h, k1);
	insert_str_hash(h, k2);
	insert_str_hash(h, k3);
	insert_str_hash(h, k4);
}
```

For primitive types and many types of structs, the default *CAG_DEC_DEF* or *CAG_DEF* macros are often sufficient. However, the string hash table declared has a limitation. The CAGL container manages the memory of the container itself, but it does no memory management of the elements of the container.

In the *str_hash* container, if k0 through k5 were not assigned constants, but rather declared as string arrays of length 3 whose values were copied into them using strcpy, their values would be undefined as soon soon as *populate_str_hash* finished executing, even if the hash table remained alive. Attempting to access the elements in the function that called them would probably result in a obtaining garbage values or a crash.

CAGL offers a way for its containers to manage the memory of its elements. The C++ STL containers manage the memory of their elements through the constructors and destructors of those elements. C does not have constructors and destructors, so CAGL needs to be told how to allocate and de-allocate its elements.

CAGL macros that begin *CAG_DEF_ALL_* allow you to define the allocation and deallocation functions or macros for your container's elements. C++ STL programmers might think of these as the element's constructor and destructor.

Here is an example of a tree that manages the memory for C strings:

```C
CAG_DEC_TREE(string_tree, char *)
CAG_DEF_ALL_CMP_TREE(string_tree, char *, strcmp, CAG_BYVAL,
                     CAG_SIMPLE_ALLOC_STYLE, cag_strdup, free);
```

The parameters of the call to CAG_DEF_ALL_CMP_TREE are as follows:

1. *string_tree* is the name of the container type.

1. *char ** is the C string type.

1. *strcmp* is the C standard function for comparing strings.

1. *CAG_BYVAL* is a CAGL macro which tells CAGL that the comparison function for this container takes its parameters by value and there is therefore no need to prefix the parameters with the & sign. See below for an alternative to this.

1. *CAG_SIMPLE_ALLOC_STYLE* is a CAGL macro for how the allocation function should be invoked. You should almost never need to define your own allocation style macro or function, but there are alternative styles which are discussed elsewhere.

1. *cag_strdup* is a function in the CAGL cag_common.c module that allocates a C string from the heap. Most C libraries provide a *strdup* function which you could also use, or you could write your own.

1. *free* is the standard C free function that will deallocate a string once it is no longer needed.

Now you can insert strings into a *string_tree* container without worrying about allocating or deallocating its memory. CAGL will handle this for you.

## Example: Euclidean points

There are numerous examples of how to use the CAGL in the test suite programs. Here is a simple example with Euclidean points.

Let's generate a set of points, store them in a list and then find the two closest points. To demonstrate how you can write modular code with CAGL we're going to have three files:

- eg_points1.c which will contain our main function as well as functions to populate our points.
- eg_points2.c which will contain our functions that operate on points and list of points.
- eg_points.h which will contain our declarations common to eg_points1.c and eg_points2.c

In eg_points.h we'll declare our struct as follows:

```C
struct point {
	double x;
	double y;
};
```

We also need a list to store the points:

```C
#include "cagl/dlist.h"
CAG_DEC_DLIST(points, struct point);
```

So we've declared a type called *points* which is a list of *struct point*. In *eg_points2.c* we need to define our functions that operate on the *points* type:

```C
CAG_DEF_DLIST(points, struct point);
```

We'll implement two ways of calculating the shortest distance. One will use indices and the other will use iterators.

Here are the prototypes for our two functions:

```C
double shortest_distance_using_index(points *);
double shortest_distance_using_iterators(points *);
```

We'll implement two ways of populating our points. One will populate a list with points in an ordered way. Here is how we could do it:


```C
void populate_ordered(points *a, int numpoints, double x_start,
		     double x_step, double gradient)
{
	int i;
	struct point p;

	p.x = x_start;
	p.y = x_start * gradient;

	for (i = 0; i < numpoints; ++i) {
		append_points(a, p);
		p.x += x_step;
		p.y = p.x * gradient;
	}
}
```

This function takes a list by address as its first parameter. It will populate it with *numpoints* points. The first *x* point will be *x_start* and each *y* point will be the corresponding *x* point multiplied by gradient.

We use the CAGL generated *append_points* function to put each new point at the back of the list. For doubly-linked lists and arrays, the efficiency of the *append_[container type]* function is constant.

For a program for personal use, the above is sufficient, but for a production ready system, there is a problem.The *append_points* function can fail. It might not be able to allocate memory for the new point. It returns an iterator of type *it_points*. If the append was successful, this will be a pointer to the newly appended point, else it will be NULL.

C doesn't have exceptions, so we have to handle error checking at the call to *append_points*. If *append_points* fails, we want to return an error from populate_ordered, perhaps 1 for success and 0 for a failure.

Here's one way to do it:

```C
int populate_ordered(points *a, int numpoints, double x_start,
		     double x_step, double gradient)
{
	int i;
	struct point p;

	p.x = x_start;
	p.y = x_start * gradient;

	for (i = 0; i < numpoints; ++i) {
		if (append_points(a, p) == 0) {
			return CAG_FALSE;
		}
		p.x += x_step;
		p.y = p.x * gradient;
	}
	return CAG_TRUE;
}
```

*CAG_TRUE* and *CAG_FALSE* are simply macros equal to 1 and 0 respectively. You don't have to use them. (Why haven't we used the C99 bool type? We could, but unless otherwise specified all the examples here are C89 compatible.)

Now here's code in our *main()* function that declares a list of points and calls the *populate_ordered* function. It also prints out all the points.

```C
	points ordered;
	it_points it;

	if (new_points(&ordered) == CAG_FALSE) {
		fprintf(stderr, "Error initialising array.\n");
		exit(1);
	}
	if (populate_ordered(&ordered, 5, 0.0, 10.0, 2.0) == CAG_FALSE)  {
		fprintf(stderr, "Error populating array.\n");
		exit(1);
	}
	printf("Ordered points:\n");
	for (it = beg_points(&ordered); it != end_points(&ordered);
	     it = next_points(it))
		printf("(%0.1f, %0.1f)\n", it->value.x, it->value.y);
	free_points(&ordered);
```

We checked that the call to *new_points* didn't produce an error. All CAGL functions that can produce an error return a pointer. If the pointer is NULL, an error has occurred.

We also used an iterator *it* to step through the list. And we called *free_points* to return any memory we allocated to the heap.

Some C style guides explicitly recommend against hiding pointers in *typedef*s like CAGL does with iterators. If you're following such a style guide, instead of declaring *it* like this:

```C
it_points it;
```

you can instead do this

```C
struct iterator_points *it;
```

In all our examples and in the actual CAGL code, we use the *typedef* version. The two declarations are effectively identical. Which you chose to use is up to you.

Here's a function to populate the list with randomly generated points. But notice that here we call *appendp_points* instead of *append_points*. In CAGL, if the verb of the function ends with a *p*, then the function takes its element parameter by address -- as a pointer --  not by value. In this example it makes little difference, but if the elements of our container are large, for example if each element is a container, then the *appendp* version will be much more efficient because it won't copy the entire structure when calling the append function.

```C
int populate_random(points *a, int numpoints, int maxval)
{
	int i;
	struct point p;

	for (i = 0; i < numpoints; ++i) {
		/* Not a good way to generate random values but
		   sufficient for our purposes.
		 */
		p.x = rand() % maxval;
		p.y = rand() % maxval;
		if (appendp_points(a, &p) == 0) {
			return CAG_FALSE;
		}
	}
	return CAG_TRUE;
}
```

And here's corresponding code in *main()*. Here too we do something different.

Instead of iterating using an explicitly defined for loop, we use the *CAG_FOR_ALL* macro. It takes four parameters: the name of the container type, *points*, the container variable, *random*, which must be a pointer hence we pass it by address, an iterator over the container, *it*, and code to execute on each iteration of the loop. Here we only execute one statement, a *printf*. But if we had multiple statements, we would have to enclose the code in curly brackets.

Note that *it* is iterated by the macro over all the elements in our container *random*. Using a macro to abstract away a for loop is not every C programmer's cup of tea. In which case, feel free to use the method above.

```C
	points random;
	it_points it;

	if (new_points(&random) == CAG_FALSE) {
		fprintf(stderr, "Error initialising array.\n");
		exit(1);
	}
	if (populate_random(&random, 5, 50) == CAG_FALSE)  {
		fprintf(stderr, "Error populating array.\n");
		exit(1);
	}
	printf("Random points:\n");
	CAG_FOR_ALL(points, &random, it,
		        printf("(%0.1f, %0.1f)\n", it->value.x, it->value.y));
	free_points(&random);
```

Now in file2.c we will implement our two shortest distance functions. They use a brute force method which is simple but inefficient. For our purposes, the brute force method is sufficient. The algorithm steps through each point in the list except the last and calculates its Euclidean distance to every point in front of it, updating the smallest distance found if necessary.

Here's our implementation:

```C
double shortest_distance_using_index(points *a)
{
	int i, j;
	int num_points;

	double min_dist = DBL_MAX;
	num_points = distance_all_points(a);
	for (i = 0; i < num_points - 1; ++i) {
		struct point p1 = index_points(a, i)->value;
		for (j = i + 1; j < num_points; ++j) {
			struct point p2 = index_points(a, j)->value;
			double d =
				(p1.x - p2.x) * (p1.x - p2.x) +
				(p1.y - p2.y) * (p1.y - p2.y);
			if (d < min_dist)
				min_dist = d;
		}
	}
	return sqrt(min_dist);
}
```C

This method uses indices, *i* and *j*, to step through the list. It uses two CAGL functions, *distance_all_points*, which returns the number of elements in the list, and *index_points_points*, which returns an iterator to the *i*'th or *j*'th element in the container.

Here's another way of doing it using iterators:

```C
double shortest_distance_using_iterators(points *a)
{
	it_points i, j;
	double min_dist = DBL_MAX;

	for (i = beg_points(a); i != prev_points(end_points(a));
	     i = next_points(i)) {
		struct point p1 = i->value;
		for (j = next_points(i); j != end_points(a);
		     j = next_points(j)) {
			struct point p2 = j->value;
			double d =
				(p1.x - p2.x) * (p1.x - p2.x) +
				(p1.y - p2.y) * (p1.y - p2.y);
			if (d < min_dist)
				min_dist = d;
		}
	}
	return sqrt(min_dist);
}
```

Every CAGL container has functions called *beg_[container]*, *begin_[container]* (exactly the same as *beg_[container]*), *next_[container]*, *distance_[container]*, *distance_all_[container]* and *end_[container]*.

So which is the better method to use? For lists, *distance_all* is an O(n) operation. So is *index_* but for arrays these are both constant-time operations. Undoubtedly for lists, the iterator version is more efficient. But if you declare *points* as an array type instead of a doubly-linked list type, then there is little to separate the efficiency of the two implementations.

Here is our complete *main()* function which uses both of these shortest distance functions:

```C
int main(void)
{
	points ordered, random;
	it_points it;

	if (new_points(&ordered) == CAG_FALSE) {
		fprintf(stderr, "Error initialising array.\n");
		exit(1);
	}
	if (populate_ordered(&ordered, 5, 0.0, 10.0, 2.0) == CAG_FALSE)  {
		fprintf(stderr, "Error populating array.\n");
		exit(1);
	}
	printf("Ordered points:\n");
	for (it = beg_points(&ordered); it != end_points(&ordered);
	     it = next_points(it))
		printf("(%0.1f, %0.1f)\n", it->value.x, it->value.y);
	printf("Shortest distance using index is: %.1f\n",
	       shortest_distance_using_index(&ordered));
	printf("Shortest distance using iterators is: %.1f\n",
	       shortest_distance_using_iterators(&ordered));
	free_points(&ordered);

	if (new_points(&random) == CAG_FALSE) {
		fprintf(stderr, "Error initialising array.\n");
		exit(1);
	}
	if (populate_random(&random, 5, 50) == CAG_FALSE)  {
		fprintf(stderr, "Error populating array.\n");
		exit(1);
	}
	printf("Random points:\n");
	CAG_FOR_ALL(points, &random, it,
		    printf("(%0.1f, %0.1f)\n", it->value.x, it->value.y));
	printf("Shortest distance using index is: %.1f\n",
	       shortest_distance_using_index(&random));
	printf("Shortest distance using iterators is: %.1f\n",
	       shortest_distance_using_iterators(&random));
	free_points(&random);

	return 0;
}
```

The complete code for this example can be found in the examples directory of the CAGL repository.

And here's sample output:

    Ordered points:
    (0.0, 0.0)
    (10.0, 20.0)
    (20.0, 40.0)
    (30.0, 60.0)
    (40.0, 80.0)
    Shortest distance using index is: 22.4
    Shortest distance using iterators is: 22.4
    Random points:
    (33.0, 36.0)
    (27.0, 15.0)
    (43.0, 35.0)
    (36.0, 42.0)
    (49.0, 21.0)
    Shortest distance using index is: 6.7
    Shortest distance using iterators is: 6.7


## Example: Deck of cards

Let's use CAGL to manage a deck of cards which we'll store in an array. To keep things simple, we'll write all the code in one file this time. We'll also order our cards according to the [high-card by suit[(http://en.wikipedia.org/wiki/High_card_by_suit) convention. To compare the order of two cards, first compare their rank. If the ranks are the same, compare their suits alphabetically. So clubs is lowest, followed by diamonds, hearts and spades.

We create a file called *eg_cards.c*. Here are the first few lines:

```C
#include <stdio.h>
#include <stdlib.h>
#include "cagl/array.h"

struct card {
	int rank;
	char suit;
};
```

We now want to declare a CAGL array type called *deck*, but we want to use CAGL to order the deck if necessary, so we need to use the *CAG_DEC_CMP_ARRAY* macro. The *CMP* tells CAGL that this array has a comparison function.

As a first attempt we could write this comparison function:

```C
int cmp_cards(const struct card c1, const struct card c2)
{
	int r = c1.rank - c2.rank;
	return r == 0 ? c1.suit - c2.suit : r;
}
```

And then declare our deck like this:

```C
CAG_DEC_DEF_CMP_ARRAY(deck, struct card, cmp_cards);
```

If we were splitting this code over multiple files, we would use two macros, *CAG_DEC_CMP_ARRAY* and CAG_DEF_CMP_ARRAY

Note that our comparison function, *cmp_cards*, takes its parameters by value. For a small struct like *card* this is not serious. But it would be inefficient if we were comparing two large *struct*s. We would prefer to write our comparison function like this:

```C
int cmp_cards(const struct card *c1, const struct card *c2)
{
	int r = c1->rank - c2->rank;
	return r == 0 ? c1->suit - c2->suit : r;
}
```

CAGL supports this possibility but we have to use a slightly more complicated macro: *CAG_DEC_DEF_ALL_CMP_ARRAY*. The *ALL* means there are no default parameters to the macro.

The correct way to declare and define the *deck* array using the pass-by-address version of *cmp_cards* is:

```C
CAG_DEC_DEF_ALL_CMP_ARRAY(deck, struct card, cmp_card, CAG_BYADR,
			  CAG_NO_ALLOC_STYLE, CAG_NO_ALLOC_FUNC,
			  CAG_NO_FREE_FUNC);
```

That might look a bit intimidating, but usually for *struct*s the fourth parameter onwards are either the same as above, or one variation of it.

Incidentally, you could declare this in two macros as follows:

```C
CAG_DEC_CMP_ARRAY(deck, struct card);
CAG_DEF_ALL_CMP_ARRAY(deck, struct card, cmp_cards, CAG_BYADR,
			  CAG_NO_ALLOC_STYLE, CAG_NO_ALLOC_FUNC,
			  CAG_NO_FREE_FUNC);
```
It's identical except that you would use the two-macro version if *deck* was needed in multiple modules.

Here are what the parameters from the fourth one onwards mean:

- *CAG_BYADR* is a CAGL supplied macro telling CAGL that the comparison function takes its parameter by address. Actually *CAG_BYADR* is simply equal to the ampersand *&*, and each time CAGL calls the *cmp_cards* it will now put an ampersand before the parameters. The alternative is *CAG_BYVAL* which tells CAGL the comparison function is by value.

- *CAG_NO_ALLOC_STYLE* is a macro which tells CAGL not to do any special heap allocation for the elements of this array.

- *CAG_NO_ALLOC_FUNC* is a macro used by *CAG_NO_ALLOC_STYLE*.

- *CAG_NO_FREE_FUNC* is a macro telling CAGL not to deallocate (free) the elements of the array when its finished with them.

(Our next example looks at a variation of this where we do need the elements to be allocated and freed from the heap.)

Moving on, we want to populate our deck of cards so we write this function, which intentionally does not load the cards in order.

```C
int populate_deck(deck *d)
{
	int rank;
	struct card crd;

	for (rank = 0; rank < 13; ++rank) {
		crd.rank = rank;
		crd.suit = 'C';
        /* You might prefer to write the next line as:
		   if (appendp_deck(d, &crd) == NULL) return CAG_FALSE;
		*/
		if (!appendp_deck(d, &crd)) return CAG_FALSE;
		crd.suit = 'D';
		if (!appendp_deck(d, &crd)) return CAG_FALSE;
		crd.suit = 'H';
		if (!appendp_deck(d, &crd)) return CAG_FALSE;
		crd.suit = 'S';
		if (!appendp_deck(d, &crd)) return CAG_FALSE;
	}
	return CAG_TRUE;
}
```

We also need to pretty-print our cards:

```C
char *rank_names[] =
{
	"2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"
};

void print_card(const struct card *c)
{
	printf("%s%c", rank_names[c->rank], c->suit);
}

void print_deck(const deck *d)
{
	it_deck it;

	CAG_FOR_ALL(deck, d, it,
		    {
			    print_card(&it->value);
			    printf(" ");
		    });
	printf("\n");
}
```

Here's the first version of our *main()* function:

```C
int main(void)
{
	deck d;
	if (!new_deck(&d)) {
		fprintf(stderr, "Error creating deck\n");
		exit(1);
	};
	if (!populate_deck(&d)) {
		fprintf(stderr, "Error populating deck\n");
		exit(1);
	}
	print_deck(&d);
	free_deck(&d);
	return 0;
}
```

The output is:

    2S 2H 2D 2C 3S 3H 3D 3C 4S 4H 4D 4C 5S 5H 5D 5C 6S 6H 6D 6C 7S 7H 7D 7C 8S 8H 8D 8C 9S 9H 9D 9C 10S 10H 10D 10C JS JH JD JC QS QH QD QC KS KH KD KC AS AH AD AC

That's not the correct order of a pack though. We can use the CAGL generated sort function to fix that:

```C
sort_deck(beg_deck(&d), end_deck(&d));
```

The *sort_[container]* function takes two iterators over the same container as parameters and sorts the elements in that range. Many CAGL functions work this way. But operating on an entire container is so common, that the CAGL also often provides a short-hand function so we don't have to type *beg_deck(&d), end_deck(&d)*. This does the trick:

```C
sort_all_deck(&d);
```

We can sort the array from highest to lowest card instead of from lowest to highest. To do this we use reverse iterators. For containers that are bidirectional (arrays, doubly-linked lists and trees), many analogous functions that operate on reverse iterators are provided. These are prefixed *r*.

For example, for sorting, *rsort_deck* and *rsort_all_deck* are provided. This is how *rsort_deck* is invoked:

```C
rsort_deck(rbeg_deck(&d), rend_deck(&d));
```

Note the use of reverse versions of *beg_deck* and *end_deck*. Alternately we can be more succinct:

```C
rsort_all_deck(&d);
```

We can also shuffle our deck with a CAGL provided function:

```C
random_shuffle_deck(beg_deck(&d), end_deck(&d));
```

Or more succinctly:

```C
random_shuffle_all_deck(&d);
```

Here's our completed, admittedly rather contrived, *main()* function:

```C
int main(void)
{
	deck d;
	if (!new_deck(&d)) {
		fprintf(stderr, "Error creating deck\n");
		exit(1);
	};
	if (!populate_deck(&d)) {
		fprintf(stderr, "Error populating deck\n");
		exit(1);
	}
	printf("After populating the deck\n");
	print_deck(&d);
	sort_all_deck(&d);
	printf("After sorting the deck\n");
	print_deck(&d);
	rsort_all_deck(&d);
	printf("After reverse sorting the deck\n");
	print_deck(&d);
	random_shuffle_all_deck(&d);
	printf("After shuffling the deck\n");
	print_deck(&d);
	free_deck(&d);
	return 0;
}
```

The output might look like this:

    After populating the deck
    2S 2H 2D 2C 3S 3H 3D 3C 4S 4H 4D 4C 5S 5H 5D 5C 6S 6H 6D 6C 7S 7H 7D 7C 8S 8H 8D 8C 9S 9H 9D 9C 10S 10H 10D 10C JS JH JD JC QS QH QD QC KS KH KD KC AS AH AD AC
    After sorting the deck
    2C 2D 2H 2S 3C 3D 3H 3S 4C 4D 4H 4S 5C 5D 5H 5S 6C 6D 6H 6S 7C 7D 7H 7S 8C 8D 8H 8S 9C 9D 9H 9S 10C 10D 10H 10S JC JD JH JS QC QD QH QS KC KD KH KS AC AD AH AS
    After reverse sorting the deck
    AS AH AD AC KS KH KD KC QS QH QD QC JS JH JD JC 10S 10H 10D 10C 9S 9H 9D 9C 8S 8H 8D 8C 7S 7H 7D 7C 6S 6H 6D 6C 5S 5H 5D 5C 4S 4H 4D 4C 3S 3H 3D 3C 2S 2H 2D 2C
    After shuffling the deck
    AD 6D KC AH 4H 4S 10H 9C 5S 2C 3S 7C 7H JC 10C 3D 6C 6H 3H 10D QH QC 8S KD JD 9S 2S 6S 4D 7D AC JS 5D 3C KS QS AS 4C KH 8C 8H 2H 5C 9D 2D 7S 9H 8D JH 5H 10S QD

## Example: a dictionary

In this example, we want to create a dictionary for storing words and their meanings. In other words we want a balanced binary tree whose elements are this:

```C
struct entry {
	char *word;
	char *definition;
};
```

At the top of the program, *eg_dictionary.c*, we need some include files:

```C
#include <stdio.h>
#include <stdlib.h>

#include "cagl/tree.h"
```

We also need a comparison function so that our dictionary can be ordered.

```C
int cmp_entry(const struct entry *e1, const struct entry *e2)
{
	return strcmp(e1->word, e2->word);
}
```

We are lazy (or very cautious) and want the CAGL to manage the memory of our dictionary entries. But the *entry struct* members are pointers whose memory needs to be managed. In C++ you would do this by writing a constructor and destructor for *entry* and a *map<entry>* would manage the allocation and deletion of its members by calling these implicitly whenever you added or erased an element in the map. Although C doesn't have constructors or destructors, you can pass two functions to the CAGL definition which effectively serve the same purpose. Actually a copy constructor is the more appropriate analogy. When we insert an entry into the tree we will copy it from an existing *struct entry*.

Here is a function to allocate (or copy-construct if you like) a new entry:

```C
int alloc_entry(struct entry *to, const struct entry *from)
{
	to->word = cag_strdup(from->word);
	if (!to->word)
		return CAG_FALSE;
	to->definition = cag_strdup(from->definition);
	if (!to->definition) {
		free(to->word);
		return CAG_FALSE;
	}
	return CAG_TRUE;
}
```

Note the use of the *cag_strdup* function. You could easily write your own one or, if you use GNU/Linux, use the *strdup* function. (But strdup, despite its ubiquity is not part of the standard ISO C library.)

We also need to free entries once they're erased or no longer used:

```C
void free_entry(struct entry *e)
{
	free(e->word);
	free(e->definition);
}
```

Now we can create our CAGL dictionary type:

```C
CAG_DEC_DEF_ALL_CMP_TREE(dictionary, struct entry, cmp_entry, CAG_BYADR,
			             CAG_STRUCT_ALLOC_STYLE, alloc_entry, free_entry);
```

Here's what the fourth parameter onwards mean:

- *CAG_BYADR*: means our comparison function, *cmp_entry* in this case, takes its parameters by address.
- *CAG_STRUCT_ALLOC_STYLE*: is a CAGL macro that allocates the memory for *struct*s. Since *entry* is a struct and we want CAGL to manage its memory, this is the correct allocation style parameter to use.
- *alloc_entry*: is our function for allocating the memory of an entry. It will be called by the code in *CAG_STRUCT_ALLOC_STYLE*.
- *free_entry*: is our function to return an entry's memory to the heap.

Again, we could have declared and defined the dictionary like this instead with the same results:

```C
CAG_DEC_CMP_TREE(dictionary, struct entry);
CAG_DEF_ALL_CMP_TREE(dictionary, struct entry, cmp_entry, CAG_BYADR,
                     CAG_STRUCT_ALLOC_STYLE, alloc_entry, free_entry);
```

However, if we'd declared our dictionary like this:

```C
CAG_DEC_DEF_CMP_TREE(dictionary, struct entry, cmp_entry)
```

Then we'd have to rewrite our comparison function to accept its parameters by value and we'd have to manage the memory of all our entries.

And if we did it like this:

```C
CAG_DEC_DEF_ALL_CMP_ARRAY(deck, struct card, cmp_cards, CAG_BYADR,
                          CAG_NO_ALLOC_STYLE, CAG_NO_ALLOC_FUNC,
			              CAG_NO_FREE_FUNC);
```

Then we would not have to rewrite our comparison function, but we would have to manage the memory of each entry. By now you should be understanding the difference between the different types of container declaration and definition macros as well as the different kinds of parameters they accept.

Here's our code to populate the dictionary:

```C
int populate_dictionary(dictionary *d)
{
	struct entry e;

	e.word = "lion";
	e.definition = "Dangerous, lazy and lovable wild animal";
	if (!insertp_dictionary(d, &e)) return 0;
	e.word = "cat";
	e.definition = "Fat, lazy and lovable domestic pet";
	if (!insertp_dictionary(d, &e)) return 0;
	e.word = "springbok";
	e.definition = "type of lion food";
	if (!insertp_dictionary(d, &e)) return 0;
	e.word = "mouse";
	e.definition = "type of cat food";
	if (!insertp_dictionary(d, &e)) return 0;
	e.word = "giraffe";
	e.definition = "strange animal with absurdly long neck";
	if (!insertp_dictionary(d, &e)) return 0;
	return 1;
}
```

And here's our *main()* function, which populates the dictionary and then prints it out.

```C
int main(void)
{
	dictionary d;
	it_dictionary it;

	if (!new_dictionary(&d)) {
		fprintf(stderr, "Error initializing dictionary.\n");
		exit(1);
	};
	if (!populate_dictionary(&d)) {
		fprintf(stderr, "Error populating dictionary.\n");
		exit(1);
	}
	CAG_FOR_ALL(dictionary, &d, it,
		    printf("%s: %s\n", it->value.word, it->value.definition));
	free_dictionary(&d);
	return 0;
}
```

This is the output:

| cat: Fat, lazy and lovable domestic pet
| giraffe: strange animal with absurdly long neck
| lion: Dangerous, lazy and lovable wild animal
| mouse: type of cat food
| springbok: type of lion food

Note that it's in alphabetical order even though we inserted the entries arbitrarily. The CAGL binary tree container functions always add entries in alphabetical order and unless you wilfully find a way to invalidate the order of the tree, the tree will remain ordered. This is in contrast to arrays and lists. It's valid to scramble the order of any CAGL array or list, but the tree container is always ordered.

This example is ridiculously contrived because in practice you'd typically get the words and definitions from standard input. So let's rewrite our *populate_dictionary* function to do just that:

```C
int populate_dictionary(dictionary *d)
{
	char word[20];
	char definition[200];
	struct entry e;

	while(!feof(stdin) && strcmp(fgets(word, 20, stdin), "\n")) {
		word[strlen(word) - 1] = '\0'; /* remove newline */
		fgets(definition, 200, stdin);
		definition[strlen(definition) - 1] = '\0'; /* remove newline */
		e.word = word;
		e.definition = definition;
		if ((!insertp_dictionary(d, &e))) return CAG_FALSE;
	}
	return CAG_TRUE;
}
```

Running the program through a memory tester like *Valgrind* will show that there are no leaks.

What if you want to manually allocate your own container elements, but when the container is freed, or when elements are erased, you want CAGL to handle that? Easily done. The code below is inelegant but it'll do the trick:

```C
CAG_DEC_DEF_ALL_CMP_TREE(dictionary, struct entry, cmp_entry, CAG_BYADR,
			 CAG_NO_ALLOC_STYLE, CAG_NO_ALLOC_FUNC, free_entry);

int populate_dictionary(dictionary *d)
{
	char *word;
	char *definition;
	struct entry e;

	word = malloc(sizeof(char) * 20);
	if (!word) return CAG_FALSE;
	while(!feof(stdin) && strcmp(fgets(word, 20, stdin), "\n")) {
		word[strlen(word) - 1] = '\0'; /* remove newline */
		definition = malloc(sizeof(char) * 200);
		if (!definition) return CAG_FALSE;
		fgets(definition, 200, stdin);
		definition[strlen(definition) - 1] = '\0'; /* remove newline */
		e.word = word;
		e.definition = definition;
		if ((!insertp_dictionary(d, &e))) return CAG_FALSE;
		word = malloc(sizeof(char) * 20);
		if (!word) return CAG_FALSE;
	}
	free(word); /* free the last unused word */
	return CAG_TRUE;
}
```

## Example: Adjacency list

This example shows how to declare and define a container whose elements are containers. An adjacency list is used to represent graphs in computer science. It is typically implemented as an array of lists. In our example, the list elements are integers. This is simple to do.

We first declare and define our list.

```C
#include "cagl/array.h"
#include "cagl/slist.h"

CAG_DEC_DEF_SLIST(islist, int);
```

Then we declare and define our array of lists:

```C
CAG_DEC_DEF_ALL_ARRAY(adj_slist, islist, CAG_STRUCT_ALLOC_STYLE,
                      new_from_islist, free_islist, CAG_BYADR);
```C

The parameters are as follows:

- *adj_slist* is the the name of the adjacency matrix type we're declaring and defining.

- *islist* is the name of the type of singly-linked list of integers we've already declared and defined.

- *CAG_STRUCT_ALLOC_STYLE* is a CAGL macro that is typically used when the elements of a container are a struct whose memory management must be handled by the higher-level container. In this case we want the singly linked lists to be memory managed by CAGL.

- *new_from_islist* is a CAGL function defined for our singly linked list of integers. Every CAGL container has a *new_from_[container]* function defined. It is analogous to a C++ copy constructor and is needed for when containers are elements of other containers.

- *free_islist* is needed to destroy lists and return them to the heap when our container is finished with them.

- *CAG_BYADR* tells CAGL that the *new_from_islist* and *free_islist* functions take their parameters by address.

While some of these parameters might seem complicated, they are always the same for CAGL containers whose elements are CAGL containers.

Here's a first cut at how we could populate the list:

```C
static void populate_adj_slist(adj_slist *m, int num)
{
	int i, j;
	for (i = 0; i < num; ++i) {
		islist l;
		if (new_islist(&l) == NULL) {
			fprintf(stderr, "Out of memory %d", __LINE__);
			exit(1);
		}
		for (j = 0; j < num; ++j) {
			if (prepend_islist(&l, j) == NULL) {
				fprintf(stderr, "Out of memory %d", __LINE__);
				exit(1);
			}
		}
		if (appendp_adj_slist(m, &l) == NULL) {
				fprintf(stderr, "Out of memory %d", __LINE__);
				exit(1);
		}
		free_islist(&l);
	}
}
```

The problem with this code is that we first create the whole list in *l*. Then when we call *appendp_adj_slist*, it recopies the entire list into the element created in the array using the *new_from_islist* function. This is wasteful. We can save half the time by first appending an empty list into the array. The *new_from_islist* function now has very little work to do because it copies from an empty list into a new list. We then prepend elements directly into the list element that has been created in the array.

The following code shows how to populate the singly linked lists of the array efficiently.

```C
/*
	Example of how to populate an adjacency list represented by a matrix
	of singly-linked lists.

    Parameters:

	- m: the adjacency list

	- num the number of entries to put in the list
*/

static void populate_adj_slist_efficient(adj_slist *m, int num)
{
	int i, j;
	islist l;
	islist *pl;

	new_islist(&l);
	for (i = 0; i < num; ++i) {
		appendp_adj_slist(m, &l);
		/* Note we will populate the added list itself, not l.
		   We can populate l and then append it to the matrix,
		   but this would be inefficient and result in l's elements
		   being copied one-by-one into the element in the array.
		*/
		pl = back_adj_slist(m);
		for (j = 0; j < num; ++j)
			if (!prepend_islist(pl, j)) {
				fprintf(stderr, "Out of memory %d", __LINE__);
				exit(1);
			}
	}
	free_islist(&l);
}
```

For several examples of containers containing containers as elements, as well as a complicated example of a container within a container within a container, see *test_compound.c* in the tests directory of the CAGL distribution.


# Naming standards

CAGL is easier to use if you understand the naming conventions:

- CAGL macros are prefixed *CAG_*.

- CAGL functions are prefixed *cag_*.

- If you look at the CAGL source code, you'll notice some macros are prefixed *CAG_P_*. These are macros for internal use (the *P* is for private). Don't call them and don't depend on them to be unchanged or even continuing to exist between CAGL versions. The same goes for functions prefixed *cag_p_*.

- The container declaration and definition macros are:

    - CAG_DEC_ARRAY, CAG_DEC_DLIST and CAG_DEC_SLIST. These declare the container and iterator struct, and function prototypes. Any module that uses a CAGL container must declare its structs and prototypes.
	- CAG_DEC_CMP_ARRAY, CAG_DEC_CMP_DLIST, CAG_DEC_CMP_SLIST, CAG_DEC_CMP_TREE, CAG_DEC_CMP_HASH. These declare the container and iterator struct, and function prototypes for containers that require a comparison function.
	- CAG_DEF_ARRAY, CAG_DEF_DLIST and CAG_DEF_SLIST. These define the functions for container types. These macros should only be used once per container type. They call corresponding CAG_DEF_ALL_  prefixed macros using default parameters and are intended to cover the most common cases.
	- CAG_DEF_CMP_ARRAY, CAG_DEF_CMP_DLIST, CAG_DEF_CMP_SLIST, CAG_DEF_CMP_TREE and CAG_DEF_CMP_HASH. These define the functions for container types that require a comparison function. They call corresponding CAG_DEF_ALL_CMP__ prefixed macros using default parameters and are intended to cover the most common cases.
	- CAG_DEC_DEF_ARRAY, CAG_DEC_DEF_DLIST, CAG_DEC_DEF_SLIST. These combine declarations and definitions in one call.
	- CAG_DEC_DEF_CMP_ARRAY, CAG_DEC_DEF_CMP_DLIST, CAG_DEC_DEF_CMP_SLIST, CAG_DEC_DEF_CMP_HASH and CAG_DEC_DEF_CMP_TREE. These combine declarations and definitions in one call for container that require comparison functions.
	- CAG_DEF_ALL_ARRAY, CAG_DEF_ALL_DLIST and CAG_DEF_ALL_SLIST. These define the functions for container types. These macros should only be used once per container type. These expect more parameters than their like-named counterparts without *ALL* in them.
	- CAG_DEF_ALL_CMP_ARRAY, CAG_DEF_ALL_CMP_DLIST, CAG_DEF_ALL_CMP_SLIST, CAG_DEF_ALL_CMP_TREE and CAG_DEF_ALL_CMP_HASH. These definition macros are the most flexible and have the most number of parameters, including a comparison function.

- The functions generated for a container type are suffixed with the name of the container type.

- Functions that take an element as a parameter often come in two forms: by value or by address. The verb of the by address version will be suffixed with a *p*. E.g. *append_[container](&container variable, element)* and *appendp_[container](&container variable, &element)* are by value and by address functions respectively.

- Every container type has an iterator type defined for it: *it_[container]* or *struct iterator_[container] **.

- Bidirectional containers (arrays, doubly-linked lists and trees) also have a reverse iterator type defined: *rit_[container]* or *struct iterator_[container] **.

- Bidirectional containers have reverse iterator versions defined for several functions. Reverse functions are prefixed with an *r*, e.g. *rsort_all_[container]*.

- Some functions have variations that can operate on a single element and a range of elements. The version that operates on a range will have its verb suffixed with *range_*. E.g. *erase_[container]*, *erase_range_[container]*. However, if a function only sensibly can operate on a range, then the *range_* suffix is omitted. E.g. there is a *sort_* function but not a *sort_range_* one.

- Functions that operate on a range typically can also operate on the entire container and a *_all* version will be defined. E.g. *sort_all_[container]* and *random_shuffle_all_[container]*.

# Design principles

CAGL is designed with these principles in mind:

1. Correctness: Containers and their functions should do what they intend to do. The documentation must be consistent with the library.

1. Efficiency: Container functions should be fast and occupy minimal space. Speed is usually more important than space.

1. Simplicity: CAGL containers must be easy to use. Functions must be consistently named across container types and also behave consistently.

CAGL containers and their supporting functions are intended to cover common use cases, to reduce the drudgery and repetition of programming, as well as to relieve programmers from the hassle of coding more complicated data structures like hash tables and red-black trees, so that they can focus on their core work.

It is not the aim of the CAGL to provide specialised containers. For example, hash tables are a vital part of chess programs. A chess programmer might use the CAGL to define a hash table for storing chess positions, but as the program develops and every last ounce of speed and efficiency must be squeezed out of the hash table, the CAGL hash table would likely have to be replaced with a specialised one.

While containers other than arrays, lists, trees and hash tables are envisaged for CAGL, feature creep will be avoided. CAGL is meant to bring some of the *niceness* of the STL to C users, but it is not intended to ever be as comprehensive or flexible as the STL, nor as obscure as the STL can sometimes be.

See the file TODO.md for the features being considered for CAGL.

# Portability

CAGL is compatible with ANSI C 1989 compliant compilers, as well as subsequent standard versions of C. The 1989 C definition specifies an archaic limitation that external variable names that share the first six characters do not have to be treated as unique. This is not a limitation for any modern C compiler and since adhering to it would have rendered CAGL impractical, it is ignored, as it is by most useful C libraries.

The test suite currently compiles without warnings and executes 100% successfully using GNU C and Clang with these options:

*-Wall -pedantic -Wstrict-prototypes -Wextra*

It is intended that the test suite of future versions of CAGL will also be compiled, without generating warnings, and executed with Microsoft's and Intel's C compilers.

Currently CAGL is tested under GNU/Linux. Future tests should also be carried out under Windows and OS X.

# Arrays

CAGL arrays support random access and grow automatically.

## Macros to declare and/or define arrays

### CAG_DEC_ARRAY {-}

#### Syntax {-}

```C
CAG_DEC_ARRAY(container, type)
```

#### Description {-}

Declares a container type called *container* with elements of type *type*.

### CAG_DEF_ARRAY {-}

#### Syntax {-}

```C
CAG_DEF_ARRAY(container, type);
```

#### Description {-}

Defines the functions for a CAGL array container type called *container*, which has elements of type *type*. Usually used in conjunction with *CAG_DEC_ARRAY*.

### CAG_DEC_DEF_ARRAY {-}

#### Syntax {-}

```C
CAG_DEC_DEF_ARRAY(container, type)
```


#### Description {-}

This is equivalent to calling *CAG_DEC_ARRAY(container, type)* and *CAG_DEF_ARRAY(container, type)*.


### CAG_DEC_CMP_ARRAY {-}

#### Syntax {-}

```C
CAG_DEC_CMP_ARRAY(container, type)
```

#### Description {-}

Declares a type called *container* which is a CAGL array container with elements of type *type*. In addition to declaring the same prototypes as *CAG_DEC_ARRAY* it also declares prototypes that facilitate ordering the container.


### CAG_DEF_CMP_ARRAY {-}

#### Syntax {-}

```C
CAG_DEF_CMP_ARRAY(container, type, cmp_func);
```

Defines the functions for an orderable CAGL array container type called *container*, which has elements of type *type* and a comparison function *cmp_func*. Usually used in conjunction with *CAG_DEC_CMP_ARRAY*.

The *cmp_func* function is of the form:

```C
int cmp_func(type e1, type e2);
```

### CAG_DEC_DEF_CMP_ARRAY {-}

#### Syntax {-}

```C
CAG_DEC_DEF_CMP_ARRAY(container, type, cmp_func);
```

#### Description {-}

This is equivalent to:

```C
CAG_DEC_CMP_ARRAY(container, type)* and *CAG_DEF_CMP_ARRAY(container, type, cmp_func)*.
```

### CAG_DEF_ALL_ARRAY {-}

#### Syntax {-}

```C
CAG_DEF_ALL(container, type, alloc_style, alloc_func, free_func, val_adr)
```

#### Description {-}

Defines the functions for a CAGL array container type. Usually used in conjunction with *CAG_DEC_ARRAY*.

#### Parameters {-}

- container: Name of the container type

- type: Type of the container's elements.

- alloc_style: Allocation style for managing the creation of elements in the container. See [Allocation Style Macros].

- alloc_func: Function that allocates memory and, optionally, initializes the element.

	For an *alloc_style* of *CAG_NO_ALLOC_STYLE* set this to *CAG_NO_ALLOC_FUNC*.

	For an *alloc_style* of *CAG_SIMPLE_ALLOC_STYLE*, this should typically be set to *malloc* or *CAG_ALLOC* (which is by default equal to *malloc*).

	For an *alloc_style* of *CAG_STRUCT_ALLOC_STYLE*, this is usually a custom written function or, in the case where the element is a CAGL container, a *new_from_[container]* function.

- free_func: Function to destroy an element and return its memory to the heap.

    For an *alloc_style* of *CAG_NO_ALLOC_STYLE* set this to *CAG_NO_FREE_FUNC*.

	For an *alloc_style* of *CAG_SIMPLE_ALLOC_STYLE*, this should typically be set to free or CAG_FREE (which is by default equal to free).

	For an *alloc_style* of *CAG_STRUCT_ALLOC_STYLE*, this is usually a custom written function or, in the case where the element is a CAGL container, a *free_[container]* function.

- val_adr: Indicates whether the allocation function, *alloc_func* and *free_func*, takes their parameters by address or by value. Both functions have to either take all their parameters by address or by value.

	For an *alloc_func* of *CAG_NO_ALLOC_FUNC* it makes no difference what this is set to because it isn't used.

    For an *alloc_func* of *malloc* or *CAG_ALLOC* this should usually be set to *CAG_BYVAL*. This might seem counter-intuitive because *malloc* and *free* take void parameters by address. But if the element of the container is a pointer, you want to pass it as is to *malloc* and *free*; you don't want to pass it by the address of the pointer.

	If the element is a container and  *alloc_func* is a *new_from_[container]* function, then this should be set CAG_BYADR.

	If *alloc_func* and *free_func* are custom written then it is up to the programmer, but *alloc_func* and *free_func* both have to use the same parameter passing method. Also if the container has a *cmp_func*, it too must have the same parameter passing method.

### CAG_DEC_DEF_ALL_ARRAY {-}

#### Syntax {-}

```C
CAG_DEC_DEF_ALL_ARRAY(container, type, alloc_style, alloc_func, free_func, val_adr);
```

#### Description {-}

This is equivalent to calling CAG_DEC_ARRAY(container, type) followed by CAG_DEF_ALL_ARRAY(container, type, alloc_style, alloc_func, free_func, val_adr).

### CAG_DEF_ALL_CMP_ARRAY {-}

#### Syntax {-}

```C
CAG_DEF_ALL_CMP_ARRAY(container, type, cmp_func, val_adr, alloc_style, alloc_func, free_func);
```

#### Description {-}

Defines the functions for an orderable CAGL array container type. Usually used in conjunction with [CAG_DEC_CMP_ARRAY].

#### Parameters {-}

- container: Name of the container type

- type: Type of the container's elements.

- cmp_func: Comparison function for ordering the container. It is of the form:

    ```C
    int cmp_func(type e1, type e2);
    ```

- val_adr: Indicates whether the comparison function, *cmp_func*, allocation function, *alloc_func* and *free_func*, take their parameters by address or by value. All three functions have to either take all their parameters by address or by value.

	For an *alloc_func* of *CAG_NO_ALLOC_FUNC* it makes no difference what this is set to because it isn't used.

    For an *alloc_func* of *malloc* or *CAG_ALLOC* this should usually be set to *CAG_BYVAL*. This might seem counter-intuitive because *malloc* and *free* take void parameters by address. But if the element of the container is a pointer, you want to pass it as is to *malloc* and *free*; you don't want to pass it by the address of the pointer.

	If the element is a container and  *alloc_func* is a *new_from_[container]* function, then this should be set CAG_BYADR.

	If *alloc_func* and *free_func* are custom written then it is up to the programmer, but *alloc_func* and *free_func* both have to use the same parameter passing method. Also if the container has a *cmp_func*, it too must have the same parameter passing method.

- alloc_style: Allocation style for managing the creation of elements in the container. See [Allocation Style Macros].

- alloc_func: Function that allocates memory and, optionally, initializes the element.

	For an *alloc_style* of *CAG_NO_ALLOC_STYLE* set this to *CAG_NO_ALLOC_FUNC*.

	For an *alloc_style* of *CAG_SIMPLE_ALLOC_STYLE*, this should typically be set to *malloc* or *CAG_ALLOC* (which is by default equal to *malloc*).

	For an *alloc_style* of *CAG_STRUCT_ALLOC_STYLE*, this is usually a custom written function or, in the case where the element is a CAGL container, a *new_from_[container]* function.

- free_func: Function to destroy an element and return its memory to the heap.

    For an *alloc_style* of *CAG_NO_ALLOC_STYLE* set this to *CAG_NO_FREE_FUNC*.

	For an *alloc_style* of *CAG_SIMPLE_ALLOC_STYLE*, this should typically be set to free or CAG_FREE (which is by default equal to free).

	For an *alloc_style* of *CAG_STRUCT_ALLOC_STYLE*, this is usually a custom written function or, in the case where the element is a CAGL container, a *free_[container]* function.

## Array structs and functions

In this reference guide *C* is used to refer to a container type and *T* is used to refer to an element type. In code, C and T must be substituted with the names of the container and element type names respectively.

The functions below are documented in [Functions][#Functions].

Only use the functions, structs and typedefs documented here in your array containers. If you notice that a function, struct or typedef that is declared in the code is omitted here, then it is best to assume it is experimental or private and subject to change in future versions of CAGL (including bug fixes) without warning or explanation.


```C

/* Iterators */
struct iterator_C {
    T value;
};
struct reverse_iterator_C {
    T value;
};
typedef struct iterator_C iterator_C;
typedef struct reverse_iterator_C reverse_iterator_C;
typedef iterator_C *it_C;
typedef reverse_iterator_C *rit_C;

/* Container struct */
struct C {
    size_t capacity; /* Treat as read-only */
    ... /* internal variables */
};
typedef struct C C;

/***************************/
/* NEW AND FREE FUNCTIONS. */
/***************************/

/* Initialize *array* and return pointer to it. */
C *new_C(C * array);

/* Initialize *array* and allocate space for *capacity* elements.
   Returns pointer to *array*. */
C *new_with_capacity_C(C * array, const size_t capacity);

/* Initialize array and allocate space for at least *size* new elements.
   Fill the array with size elements.
*/
C *new_with_size_C(C * array, const size_t size);

/* Applies new to *to* and copies the contents of *from* into it.
   Essential for containers that are the elements of containers and whose
   memory must be managed by the parent container.
   Returns a pointer to *to*.
   O(n) operation, where n is the number of elements in *from*.
*/
C *new_from_C(C * to, const C * from);

/* Call *new_C* on every argument (which must all be pointers to container
   variables) except the last which must be NULL. Returns immediately if an
   error occurs (i.e. no further container variables will be initialized).
   Returns the number of successfully initialized container variables.
   While marginally less efficient than calling *new_C* yourself on every
   container, this is convenient in functions that have to initialize many
   container variables. Works well in conjunction with *free_many_C*.
*/
int new_many_C(C * c, ...);

/* Destroys *array* and returns its memory to heap.
   This should be called when the array is no longer used.
*/
void free_C(C * array);

/* Calls *free_C* on a maximum of *max* container variables specified by the
   second argument onwards. The last argument must be NULL. This is slightly
   less  efficient than calling *free_C* yourself on each variable, but
   this can be convenient in functions that need to use many containers.
*/
void free_many_C(int max, C * c1, ...);

/**********************/
/* ITERATOR FUNCTIONS */
/**********************/

/* Set the array to have a minimum number of *size* elements.
   Useful before calling *copy_over*.
*/
it_C set_min_size_C(C * array, it_C it, const size_t size);

/* Set the array to have exactly *size* elements. If there are already more than
   size elements, erase the excess ones.  Useful before calling *copy_over*,
   but beware that data can be erased.
*/
it_C set_exact_size_C(C * array, const size_t size);

/* Return the next iterator in the array.
   Forward and reverse iterator versions supplied.
   For arrays these are equivalent to ++it and --it respectively.
*/
it_C next_C(it_C const it);
rit_C rnext_C(rit_C const it);


/* Return the previous iterator in the array.
   Forward and reverse iterator versions supplied.
   For arrays these are equivalent to --it and ++it respectively.
*/
it_C prev_C(it_C const it);
rit_C rprev_C(rit_C const it);


/* Return the iterator *n* elements away from *it*.
   Forward and reverse iterator versions supplied.
   For arrays Equivalent to  it + n and it - n respectively.
*/
it_C at_C(it_C it, const size_t n);
rit_C rat_C(rit_C it, const size_t n);

/* Returns an iterator to the *n*th element of the array. */
it_C index_C(C * array, size_t n);

/* Return the number of elements from *from* to *to* excluding *to*.
   Forward and reverse iterator versions supplied, as well as *all* version
   over entire container. *size_C* is equivalent to *distance_all* but is
   only available for arrays.
   For arrays, equivalent to: to - from and from - to for forward and reverse
   iterator versions repectively.
*/
size_t distance_C(const it_C from, const it_C to);
size_t rdistance_C(const rit_C from, const rit_C to);
size_t distance_all_C(const C * c);
size_t size_C(const C * array);

/* Indicates whether *it1* comes before *it2*. If it does then
   returns 1 else 0.
   Forward and reverse iterator versions supplied.
*/
int lt_it_C(const it_C it1, const it_C it2);
int rlt_it_C(const rit_C it1, const rit_C it2);

/* Indicates whether *it1* comes before or is the same position as *it2*.
   If it is then returns 1 else 0.
   Forward and reverse iterator versions supplied.
*/
int lteq_it_C(const it_C it1, const it_C it2);
int rlteq_it_C(const rit_C it1, const rit_C it2);

/* Returns an iterator pointing to the first element in the array (or last
   element for reverse iterator version).
   Forward and reverse iterator versions supplied.
   *beg_C* and *rbeg_C* are synonyms for *begin_C* and *rbegin_C* respectively.
*/
it_C begin_C(const C * array);
it_C beg_C = begin_C;
rit_C rbegin_C(const C * array);
rit_C rbeg_C = rbegin_C;


/* Returns an iterator pointing one past the last element in the array (or
   one before the first element for reverse iterator version).
   Forward and reverse iterator versions supplied.
*/
it_C end_C(const C * array);
rit_C rend_C(const C * array);

/*******************************/
/* ELEMENT INSERTION FUNCTIONS */
/*******************************/

/* Appends *element* to the end of *array*. Versions for passing the element
   by value and by address are provided.
   Returns iterator pointing to the appended element if successful, else NULL.
   These are efficient constant time ways to add elements to an array.
*/
it_C append_C(C * array, T const element);
it_C appendp_C(C * array, T const *element);


/* Prepends *element* to the beginning of *array*. Versions for passing the
   element by value and by address are provided.
   Returns iterator pointing to the prepended element if successful, else NULL.
   This is a slow O(n) time way of adding elements to an array.
*/
it_C prepend_C(C * array, T const element);
it_C prependp_C(C * array, T const *element);


/* Inserts *element* before *position* into *array*. Versions for passing the
   element by value and by address are provided.
   Returns iterator pointing to the prepended element if successful, else NULL.
   Every container is required to have a *put_C* function which inserts an
   element. Unless you're writing new containers, you're unlikely to need to
   use it.
   The efficiency of these functions is proportional to the size of the array
   minus *position*. The higher the value of *position*, the quicker the
   operation.
*/
it_C insert_C(C * array, it_C position, T const element);
it_C insertp_C(C * array, it_C position, T const *element);
it_C put_C(C * array, it_C position, T const element);

/* ORDERED INSERTIONS */

/* Ordered insertion functions are only available to containers defined with a
   *CMP* macro (i.e. have a user-supplied *cmp_func*), support bidirectional
   iterators and are reorderable.  Currently the only CAGL containers that
   support these are arrays and doubly linked lists.

   Returns an iterator to the inserted element.
*/

/* Insert *element* at the first position encountered for which a comparison
   is true, starting from *position*.

   By value and address versions are supplied.

*/
it_C insert_gt_C(C * array, it_C position, T const element);
it_C insert_gteq_C(C * array, it_C position, T const element);
it_C insert_lt_C(C * array, it_C position, T const element);
it_C insert_lteq_C(C * array, it_C position, T const element);



/*******************************/
/* ELEMENT RETRIEVAL FUNCTIONS */
/*******************************/

/* Returns pointer to first element of *array*. */
T *front_C(const C * array);

/* Returns pointer to last element of array. */
T *back_C(const C * array);

/************************/
/* COMPARISON FUNCTIONS */
/************************/

/* Comparison functions are only defined for container types declared with a
   definition macro that has CMP in it's name. They make use of the *cmp_func*
   function that the user has supplied.
*/

/* Compares the element in each of two iterators by calling the user-supplied
   *cmp_func* function and returning its return value.

   Return value:

   - If *cmp_func* returns a non-zero value for elements at corresponding
     positions in the two ranges being compared, then this is the value
     returned.

   - If all corresponding elements are equal (i.e. *cmp_func* returns 0 for all
     comparisons) and both ranges (or containers) have exactly the same number
     of elements, then 0 is returned (i.e. the ranges compared are precisely
     equal).

   - If all corresponding elements are equal (i.e. *cmp_func* returns 0 for all
     comparisons) and the first range (or container) has more elements than the
     second one, then 1 is returned (i.e. the first range is greater than the
     second range).

   - If all corresponding elements are equal (i.e. *cmp_func* returns 0 for all
     comparisons) and the second range (or container) has more elements than the
     first one, then 01 is returned (i.e. the first range is less than the
     second range).

   See also *equal_range_C*.
*/
int cmp_C(const it_C it1, const it_C it2);
int cmp_range_C(it_C from_1, const it_C to_1, it_C from_2,
		const it_C to_2);
int cmp_all_C(const C * c1, const C * c2);


/* Compares the elements in a range by calling the user-supplied
   *cmp_func* function and returning its return value. The comparisons
   stop once the first range or container has been iterated.

   If there are fewer elements in the second range or container than the first,
   then behaviour is undefined.

   Returns 0 if all calls to *cmp_func* return zero, else returns the first
   non-zero value of cmp_func.

*/
int equal_range_C(it_C from_1, const it_C to_1, it_C from_2);
int equal_all_C(const C * c1, const C * c2);

/*******************/
/* ERASE FUNCTIONS */
/*******************/

/* Erase the element pointed to by *it* from *array*.

   Returns iterator pointing to element that will now occupy the space
   where the erased element was.

   Time complexity: O(n) on average where n is the number of elements in
   the array.

*/
it_C erase_C(C * array, it_C it);

/* Erases all elements in the range [from, to).
   Returns *to*.
*/
it_C erase_range_C(C * c, it_C from, it_C to);

/* Empties *array*. The size (*distance_all_C*) of *array* will be zero after
   this.
   Returns an iterator equivalent to *end_C(array)*.
*/
it_C erase_all_C(C * array);

/*************************/
/* REORDERING OPERATIONS */
/*************************/

/* SORT */

/* Sort the elements [from, to). Only defined for containers with comparison
   functions. Reverse iterator and *all* versions supplied.
   To sort in reverse order, use the *rsort* versions.
   Average efficiency O(n log n). While worst case is O(n^2), it is extremely
   unlikely to occur. Implemented as a highly optimized Quicksort.
*/
it_C sort_C(it_C from, it_C to);
it_C sort_all_C(C * c);
rit_C rsort_C(rit_C from, rit_C to);
rit_C rsort_all_C(C * c);

/* Stable sorts the elements [from, to). In contrast to *sort_C* these functions
   maintain the same order of elements whose keys are equal.
   Only defined for containers with comparison functions. Reverse iterator and
   *all* versions supplied.
   To sort in reverse order, use the *rsort* versions.
   Efficiency is O(n log n). Implemented as a Mergesort.
*/
it_C stable_sort_C(it_C from, it_C to);
rit_C rstable_sort_C(rit_C from, rit_C to);
it_C stable_sort_all_C(C * c);


/* REVERSE */

/* Reverses elements in the range[from, to). *range* and *all* versions
   supplied.
   Returns an iterator to the new first element in the range.
   O(n) operation, where n is the size of the range.
*/
it_C reverse_C(it_C from, it_C to);
it_C reverse_all_C(C * array);


/* SHUFFLE */

/* Shuffles the elements in the range [from, to). *range* and *all* versions
   supplied.
   Returns an iterator to the new first element in the range.
   O(n) operation, where n is the size of the range.
*/
it_C random_shuffle_C(const it_C from, it_C to);
it_C random_shuffle_all_C(C * c);


/* SWAP */

/* Swaps the elements of two iterators.*/
void swap_C(it_C a, it_C b);
void rswap_C(rit_C a, rit_C b);


/* COPY */

/* CAGL supports two types of copying functions. The *copy_over_C* functions are
   similar to the C++ STL *copy* template function.  For these you must have
   sufficient space in the container to which you're copying. On the other hand
   *copy_C* and *copy_all_C* are similar to C++ copy constructors. When they
   copy, they allocate memory for each element in the copied to array.
*/

/* Copies the elements in the range [from, to) into *c*, which must be
   initialized but is generally empty. Space is allocated for *c*.

   The reverse iterator version copies the elements in reverse to *c*.

   Returns pointer to *c* upon success, else NULL.
*/
C *copy_C(it_C from, it_C to, C * c);
C *rcopy_C(rit_C first, rit_C last, C * c);

/* Copies all the elements in *c1* to *c2*,  which must be
   initialized but is generally empty. Space is allocated for *c2*.

   The reverse iterator version copies the elements in reverse to *c2*.

   Returns pointer to *c2* upon success, else NULL.
*/
C *copy_all_C(const C * c1, C * c2);
C *rcopy_all_C(const C * c1, C * c2);

/* Copies *c* to each of its subsequent arguments, which must be containers
   of the same type as *c*. Last parameter must be NULL. Space is allocated
   for each of the recipient containers.
   Returns the number of containers which have been successfully copied to.
*/
int copy_many_C(C * c, ...);

/* Copies the elements in the range [from, to) into *c*, which must be
   initialized but is generally empty, for those elements for which *cond_func*
   returns true.
   Space is allocated for *c*.
   Returns pointer to *c* upon success, else NULL.
*/
C *copy_if_C(it_C first, it_C last, C * c, int (*cond_func) (T *, void *),
	     void *data);

/* Copies elements in *c1*, for which *cond_func* returns TRUE,
   to *c2*,  which must be initialized but is generally empty.
   Space is allocated for *c2*.
   Returns pointer to *c2* upon success, else NULL.
*/
C *copy_if_all_C(const C * c1, C * c2, int (*cond_func) (T *, void *),
		 void *data);

/* Copies elements in the range [from, to) over result for as many elements
   as there are from *from* to *to*.
   There must be sufficient space in the remainder of the container to which
   *result* points.
*/
it_C copy_over_C(it_C from, const it_C to, it_C result);

/*************/
/* SEARCHING */
/*************/

/* Linear search for *element*, which is passed by value,
   in the range [from, to).

   By value, by address, *all*, forward and reverse iterator versions supplied.

   The *cmp_func* function, which is passed as a parameter, should return 0 if
   its two parameters are equal.

   Returns an iterator pointing to an element if found, else *to*.  O(n)
   efficiency.
*/
it_C find_C(it_C from, const it_C to, const T element,
	    int (*cmp_func) (const T *, const T *));
it_C findp_C(it_C from, const it_C to, const T * element,
	     int (*cmp_func) (const T *, const T *));
it_C find_all_C(const C * c, const T element,
		int (*cmp_func) (const T *, const T *));
it_C findp_all_C(C * c, const T * element,
		 int (*cmp_func) (const T *, const T *));
rit_C rfind_C(rit_C from, const rit_C to, const T element,
	      int (*cmp_func) (const T *, const T *));
rit_C rfindp_C(rit_C from, const rit_C to, const T * element,
	       int (*cmp_func) (const T *, const T *));



it_C insert_gt_C(C * array, it_C position, T const element);
it_C insert_gteq_C(C * array, it_C position, T const element);
it_C insert_lt_C(C * array, it_C position, T const element);
it_C insert_lteq_C(C * array, it_C position, T const element);



it_C search_C(it_C first, const it_C last, T const key);
it_C searchp_C(it_C first, const it_C last, T const *key);
it_C search_all_C(C * c, T d);
it_C searchp_all_C(C * c, T * d);
int rcmp_C(const rit_C it1, const it_C it2);
int rcmp_range_C(rit_C from_1, const rit_C to_1, it_C from_2,
		 const it_C to_2);
int rcmp_all_C(const C * c1, const C * c2);
int requal_range_C(rit_C from_1, const rit_C to_1, it_C from_2);
int requal_all_C(const C * c1, const C * c2);
rit_C rsearch_C(rit_C first, const rit_C last, T const key);
rit_C rsearchp_C(rit_C first, const rit_C last, T const *key);
it_C lower_bound_C(it_C first, it_C last, T const key);
rit_C lower_rbound_C(rit_C first, rit_C last, T const key);
it_C lower_boundp_C(it_C first, it_C last, T const *key);
rit_C lower_rboundp_C(rit_C first, rit_C last, T const *key);
it_C lower_bound_all_C(C * c, T d);
it_C lower_boundp_all_C(C * c, T * d);
int binary_search_C(it_C first, it_C last, T const key);
int binary_rsearch_C(rit_C first, rit_C last, T const key);
int binary_searchp_C(it_C first, it_C last, T const *key);
int binary_rsearchp_C(rit_C first, rit_C last, T const *key);
int binary_search_all_C(C * c, T d);
int binary_searchp_all_C(C * c, T * d);
```

### Singly-linked lists

### Doubly-linked lists

### Hash tables

### Balanced binary trees

### Iterators

#### Forward {-}

#### Bidirectional {-}

#### Reorderable {-}

#### Random access {-}

# Useful macros

### Allocation Style Macros

Containers need to know how to allocate memory for their elements. A parameter called *alloc_style* is used by the container definitions to determine this. Several predefined *allocation style* macros are provided.

**ADVANCED:** Users can write their own allocation style macros but it is rare that this should be necessary. In the case that you do wish to write an allocation style macro, see how these are used in the containers (the code in cagl/hash.h is useful to examine). All allocation style macros must take these four parameters.

to
  ~ Element being created.

from
  ~ Element from which the *to* element is being created

alloc_func
  ~ Function for allocating the memory for an element

free_code
  ~ Function for freeing the memory of allocated for a container element. This function will only be called in certain cases where an error occurred after memory for an element has been successfully allocated, but must now be freed to undo the effects of the error.

#### CAG_NO_ALLOC_STYLE {-}

```C
#define CAG_SIMPLE_ALLOC_STYLE(to, from, alloc_func, free_code)               \
    if(! (to = alloc_func(from))) free_code;
```

This allocation is typically used for containers that do not manage the memory of their elements or for elements that are primitive types.

#### CAG_SIMPLE_ALLOC_STYLE {-}

```C
#define CAG_SIMPLE_ALLOC_STYLE(to, from, alloc_func, free_code)               \
    if(! (to = alloc_func(from))) free_code;
```

This allocation style is typically used for containers whose elements are pointers and need to be managed, e.g. elements that are C strings (char *).

#### CAG_STRUCT_ALLOC_STYLE {-}

```C
#define CAG_STRUCT_ALLOC_STYLE(to, from, alloc_func, free_code)               \
    if(! (alloc_func(&to, &from))) free_code;
```

This allocation style is typically used for containers whose elements are complex structs which need custom allocation functions (analogous to C++ copy constructors) written for them.

# Modifying, enhancing and improving CAGL

You are encouraged to help improve the C Almost Generic Library (CAGL).
This document describes some of the technical "under-the-hood" details
of how the library works.

## CAGL structure

Specific code for each container is placed in its own include (.h) file. So arrays are handled in array.h. Let's say you wanted to implement a container called *stack*. You would create a file called stack.h. Examine the code in array.h to get an idea of what should go in stack.h. Pay special attention to the implementations of CAG_DEC_ARRAY, CAG_DEF_ALL_ARRAY, CAG_DEC_CMP_ARRAY and CAG_DEF_ALL_CMP_ARRAY.

All containers must implement *new*, *begin*, end* and *free* functions.

The common.h file contains generic algorithms implemented as macros. Also, there are several macros beginning CAG_DEC_ and CAG_DEF_ which are called by containers to declare and define their functions respectively.

When implementing a container such as a stack, code specific to the container will go in stack.h, but many of the algorithms, declarations and definitions in common.h should be reusable as is.

The concepts.h file reduces coding and helps CAGL containers be consistent. It helps CAGL approximate generic concepts used in the C++ STL. Containers automatically get a bunch of useful functions declared and defined by by calling the macros defined in concepts.h. Here are brief explanations of them:

CAG_DEC_FORWARD and CAG_DEF_FORWARD
  ~ These declare and define functions for containers whose iterators support the *next* operation (i.e. almost any useful container). Iterators that implement *next* are *forward* iterators.

CAG_DEC_CMP_FORWARD and CAG_DEF_CMP_FORWARD
  ~ These declare and define functions for containers that have comparison functions and support forward iterators.

CAG_DEC_BIDIRECTIONAL and CAG_DEF_BIDIRECTIONAL
  ~ Iterators that implement both *prev* and *next* functions are bidirectional. *Forward* iterators are a subset of bidirectional iterators. These macros implement functions for containers whose iterators are *bidirectional*.

CAG_DEC_CMP_BIDIRECTIONAL and CAG_DEF_CMP_BIDIRECTIONAL
  ~ These declare and define functions for containers that have comparison functions and support bidirectional iterators.

CAG_DEC_REORDERABLE and CAG_DEF_REORDERABLE
  ~ Functions for containers that can be reordered are implemented by these macros. For example arrays and lists can be reordered but the order for the elements in a binary tree cannot be changed, so arrays and lists are reorderable and binary trees are not. Hash tables have no ordering so it isn't useful to reorder their elements.

CAG_DEC_CMP_REORDERABLE and CAG_DEF_CMP_REORDERABLE
  ~ These declare and define functions for containers that have comparison functions and are reorderable.

CAG_DEC_RANDOMACCESS and CAG_DEF_RANDOMACCESS
  ~ These declare and define the functions of CAG_DEC_BIDIRECTIONAL and CAG_DEF_BIDIRECTIONAL. In addition they declare and define additional functions for containers whose iterators support an *at* function. Containers that implement an *at* operation are *random access* iterators.

CAG_DEC_CMP_RANDOMACCESS and CAG_DEF_CMP_RANDOMACCESS
  ~ These declare and define functions for containers that have comparison functions and support random access iterators.

## Coding conventions

CAGL is mostly made up of macros. There's a small amount of non-macro
code in a a few small .c libraries. This makes CAGL quite unusual. It is
hard to read complex C macros and CAGL is almost entirely composed of
them. So it's important to stick to conventions that makes reading the
code easier.

-   Use Kernighan & Ritchie coding conventions in the .h files.

-   After editing a .h file (say file.h), run: *slash79 file.h*.

-   Use the Linux Kernel coding conventions in the .c files.

-   Place the end-of-line slash \**\** in column 79.

-   All macros in CAGL start CAG\_.

-   All C functions (there aren't many of them) start cag\_.

-   Macros that are strictly for internal use should be prefixed
    CAG\_P\_ (the "P" stands for private).

## Functions and algorithms that containers usually provide


### begin\_[container]


-   Returns iterator to first element in container.

-   Parameters:

    -   Container variable

### end\_[container]

-   Returns iterator to last element in container.

-   Parameters:

    -   Container variable

### put\_[container]


Every container should have a put function that takes three parameters,
a container variable, an iterator and an element variable. The function
should insert the element variable into the container.
*put\_[container]* is used by generic algorithms like
*copy\_[container]*.

-   Returns iterator to the position in the container, such that if the
    iterator is moved forward one position, the next call to put with a
    second element would insert it immediately after the first one.

-   Parameters:

    -   Container variable to insert into

    -   Iterator to element insert after or before.

    -   Element to insert

## Macro function declaration and definition names


*apply\_func*
:   User supplied function in an apply macro. Apply macros are used to
    generate a full container version of a function that works on an
    iterator range. For example, the apply macro for
    distance\_[container](from, to) is
    distance\_all\_[container](container variable).

*at*
:   Function to find iterator that is *n* places from the input
    parameter, i.e. at\_[container].

*alloc\_style*
:   A macro to tell a container how to allocate memory for its elements.
    Three are provided by CAGL and should be sufficient for nearly all
    cases: CAG\_SIMPLE\_ALLOC\_STYLE (used for assigning allocated
    memory to pointers), CAG\_STRUCT\_ALLOC\_STYLE (used for assigning
    allocated memory to structures) and CAG\_NO\_ALLOC\_STYLE (used when
    the container does not have to assign memory for its elements).

*alloc\_func*
:   A function or macro to do memory allocation. For pointers this is
    often malloc. For containers that do not need to do memory
    allocation, use CAG\_NO\_ALLOC\_FUNC. C++ programmers can think of
    this as a constructor for the container element.

*apply\_func*
:   Function to apply to every element in a container.

*begin*
:   Function to find beginning of container, i.e. begin\_[container] or
    rbegin\_[container].

*cmp\_func*
:   Function that takes two iterators and compares their values.

*container*
:   Container type.

*container\_var*
:   Container variable.

*dir*
:   Function to step an iterator forward or backward, i.e.
    next\_[container], prev\_[container], rnext\_[container] or
    rprev\_[container].

*distance*
:   Function to calculate distance between two iterators. i.e.
    distance\_[container] or rdistance\_[container].

*end*
:   Function to find end of container, i.e. end\_[container] or
    rend\_[container].

*first*
:   Iterator pointing to the first element in a sequence. Synonymous
    with *from*.

*free\_func*
:   User provided function to free an element of a container. Use
    CAG\_NO\_FREE\_FUNC if the container does not allocate memory for
    its elements. For elements that are pointers, *free* is often
    sufficient. C++ programmers could think of this as a destructor.

*free\_code*
:   This is a parameter to an *alloc\_style* macro. It is code that
    frees any already allocated memory in the case of a failed
    allocation that succeeded partially. The partially allocated memory
    should be returned to the heap with this code. It is seldom that
    users should have to implement this.

*from*
:   Iterator pointing to the first element in a sequence. Synonymous
    with *first*.

*from\_1*
:   Iterator pointing to the first element in a sequence. Used when
    multiple sequences are being operated upon.

*from\_2*
:   Iterator pointing to the first element in a sequence. Used when
    multiple sequences are being operated upon.

*func*
:   Function supplied to generic algorithm.

*function*
:   Name of function in macro declaration and definition.

*hash\_func*
:   User provided function for hash tables, but some reasonable hashing
    functions are provided by the CAGL.

*insert\_out*
:   Function that inserts a value into an output iterator.

*it*
:   An *iterator\_type* variable mostly used in the functional
    programming macros.

*iterator\_type*
:   Iterator type, generally of the form it\_[container] or
    rit\_[container].

*iterator\_type\_1*
:   Same as *iterator\_type* but used when two or more sequences are
    operated upon.

*iterator\_type\_2*
:   Same as *iterator\_type* but used when two or more sequences are
    operated upon.

*iterator\_type\_in*
:   Same as *iterator\_type* but specifically for input sequence.

*key*
:   Usually compared against an iterator value in a search.

*last*
:   Iterator pointing to the last element in a sequence.

*length\_func*
:   User provided function that calculates the length of a type
    variable. Used for hashing.

*next*
:   Function to step an iterator forward, i.e. next\_[container] or
    rnext\_[container].

*next\_1*
:   Same as *next* but used when two are more sequences are operated
    upon.

*next\_2*
:   Same as *next* but used when two are more sequences are operated
    upon.

*next\_in*
:   Same as *next* but for input iterator.

*next\_out*
:   Same as *next* but for output iterator.

*prev*
:   Function to step an iterator backward, i.e. prev\_[container] or
    rprev\_[container].

*result*
:   Iterator pointing to first element in output sequence.

*swap*
:   Function to swap two iterators, i.e. swap\_[container].

*type*
:   Data type of the elements operated on in a container. Every CAGL
    container has an iterator type. Every iterator type has a field
    called value, which has a type indicated by this parameter.

*val\_adr*
:   Either equal to blank or &. Used by *cmp\_func* to compare by value
    or by address.

*value*
:   Function or macro to get the value of an iterator. For all CAGL
    containers, this should always be *it-\>next* where *it* is an
    iterator variable.

# Versioning and the road to a production-ready release version

The CAGL is still alpha software. The first public alpha release is version 0.1. Version 1.1 will be the first production-ready release version.

Between now and then, the names of functions might change and backward compatibility is *not* an object of development. From version 1.1 onwards, backward compatibility is vital.

Release versions have an odd first digit. Development versions have an even first digit.

The estimated release date of version 1.1 is unknown, but the aim is early 2015.

# Known bugs

Bugs are tracked in the Github repository.

# Licenses

CAGL is released under the GNU Lesser General Public License Version 3. See the file COPYING for details.

This document is released under the GNU Free Documentation License version 1.3. See the file COPYING_USER_GUIDE.

# Credits

CAGL has been written by Nathan Geffen. (nathangeffen at gmail.com).


# Appendix: Detailed function blueprint documentation


# Detailed function documentation

**WORK IN PROGRESS ON THIS PART OF THE MANUAL**

This part of the manual is going to be a long work in progress. The aim is to document every CAGL function blueprint with the following: syntax, description, parameters, data races, time and space complexity and an example.

## new {#array-new}

### Syntax {-}

```C
[container] *new_[container] ([container] * array);
```

### Description {-}

Initializes a container variable. Every CAGL container variable must be initialized with a call to a new function before any other operation is performed on the container. It is undefined to call a *new* function on a container more than once before calling a *free* function. For every call of *new* on a container variable there should be a corresponding call to *free*.

### Parameters {-}

array
  ~ The array to initialize.

Return value
  ~ On success, the initialized container, else NULL.

### Data races {-}

The array parameter is modified.

### Complexity {-}

This is an O(1) operation. It allocates CAG_QUANTUM_ARRAY * sizeof(type) bytes from the heap.

### Example {-}

```C
/* Demonstrates different uses of *new* on an array.

   While in many environment it isn't generally necessary to free memory upon
   exit of a program this demonstration does show how to exit the program
   without leaving any memory leaks.
 */

#include <stdio.h>
#include <stdlib.h>
#include "cagl/array.h"

/* Declare and define an array of integers. */
CAG_DEC_DEF_ARRAY(int_arr, int);

int main(void)
{
	int_arr a1, a2, a3, a4, a5;
	int i;

        /* Simplest use of new. Most users should use this version
	   most of the time.
	*/
	if (!new_int_arr(&a1)) {
		fprintf(stderr, "Error initialising with simple new.\n");
		/* No need to free something that wasn't successfully
		   initialized.
		 */
		exit(1);
	}

        /* Override CAGL default capacity with space for 10 elements. */
	if (!new_with_capacity_int_arr(&a2, 10)) {
		fprintf(stderr, "Error initialising with new_with_capacity.\n");
		free_int_arr(&a1);
		exit(1);
	}

        /* Insert 10 elements into a new array */
	if (!new_with_size_int_arr(&a3, 10)) {
		fprintf(stderr, "Error initialising with new_with_size.\n");
		free_int_arr(&a1);
		free_int_arr(&a2);
		exit(1);
	}

	/* Use the new_many, free_many idiom. */
	i = new_many_int_arr(&a4, &a5, NULL); /* Initialize multiple arrays. */
	if (i <= 0) {
		fprintf(stderr, "Only %d successfully initialized\n", i);
		free_many_int_arr(i, &a4, &a5, NULL);
		exit(1);
	}

	printf("Capacity of a1 is: %lu\n", a1.capacity);
	printf("Size of a1 is: %lu\n", size_int_arr(&a1));
	printf("Capacity of a2 is: %lu\n", a2.capacity);
	printf("Size of a2 is: %lu\n", size_int_arr(&a2));
	printf("Capacity of a3 is: %lu\n", a3.capacity);
	printf("Size of a3 is: %lu\n", size_int_arr(&a3));
	printf("Capacity of a4 is: %lu\n", a4.capacity);
	printf("Size of a4 is: %lu\n", size_int_arr(&a4));
	printf("Capacity of a5 is: %lu\n", a5.capacity);
	printf("Size of a5 is: %lu\n", size_int_arr(&a5));

        /* Return arrays to heap. */
	free_many_int_arr(5, &a1, &a2, &a3, &a4, &a5, NULL);
	return 0;
}
```

## new_with_capacity

### Syntax

```C
[container] *new_with_capacity_[container] ([container] * array,
	    				   const size_t capacity);
```

### Description {-}

Initializes an array and sets its capacity to a user-specified amount. The *capacity* specifies the number of elements to make space for, but the array size is initialized to zero. By default, once the capacity is reached, CAGL functions that add further elements will call realloc to attempt to get additional capacity.

### Parameters {-}

array
  ~ The array to initialize.

capacity
  ~ Enough memory is allocated to accommodate *capacity* elements in the array.

Return value
  ~ On success, the initialized container, else NULL.

### Data races {-}

The array parameter is modified.

### Complexity {-}

This is an O(1) operation. It allocates CAG_QUANTUM_ARRAY * sizeof(type) bytes from the heap.

### Example {-}

See the example for [new_[container]][#array-new].

## new_with_size {-}

### Syntax {-}

```C
[container] *new_with_size_[container] ([container] * array, const size_t size);
```

### Description {-}

Initializes an array and inserts *size* elements into it. The values of the elements are not set and no assumptions should be made about their values. The capacity of the array is set to the minimum of *size* and *CAG_QUANTUM_ARRAY*. It is useful to initialize an array using this function before calling *copy_over*.

### Parameters {-}

array
  ~ The array to initialize.

size
  ~ The array is initialized to have *size* elements.

Return value
  ~ On success, the initialized container with *size* elements, else NULL.


### Data races {-}

The array parameter is modified.

### Complexity {-}

This is an O(1) operation.

### Example {-}

See the example for [new_[container]][#array-new].
